// ---- Instructions ----
	// Variables
	#define PROGRAM_INSTRUCTION_VAR 1 // Type is inferred from value type. More than one value makes a list. args: values...
	#define PROGRAM_INSTRUCTION_GLOBAL 2 // only uses return variable
	// Peripherals
	#define PROGRAM_INSTRUCTION_OUT 3 // args: address, values...
	// Arithmatic
	#define PROGRAM_INSTRUCTION_ADD 4 // args: values...
	#define PROGRAM_INSTRUCTION_SUB 5 // args: values...
	#define PROGRAM_INSTRUCTION_MUL 6 // args: values...
	#define PROGRAM_INSTRUCTION_DIV 7 // args: values...
	#define PROGRAM_INSTRUCTION_MOD 8 // args: values...
	// Logical, using more than 2 values can be weird!
	#define PROGRAM_INSTRUCTION_EQ 9 // args: values...
	#define PROGRAM_INSTRUCTION_LT 10 // args: values...
	#define PROGRAM_INSTRUCTION_GT 11 // args: values...
	#define PROGRAM_INSTRUCTION_LTEQ 12 // args: values...
	#define PROGRAM_INSTRUCTION_GTEQ 13 // args: values...
	#define PROGRAM_INSTRUCTION_NOT 14 // args: values...
	#define PROGRAM_INSTRUCTION_OR 15 // args: values...
	#define PROGRAM_INSTRUCTION_AND 16 // args: values...
	// Control
	#define PROGRAM_INSTRUCTION_IF 17 // args: bool
	#define PROGRAM_INSTRUCTION_WHILE 18 // args: bool
	#define PROGRAM_INSTRUCTION_RETURN 19 // args: value
	// Strings
	#define PROGRAM_INSTRUCTION_CONCENCATE 20 // Join values together and return a string. args: values...
	#define PROGRAM_INSTRUCTION_FIND 21 // args: haystack, needle, start=0, end=0
	#define PROGRAM_INSTRUCTION_COPY 22 // Join values together and return a string. args: values...
	// Type
	#define PROGRAM_INSTRUCTION_TYPE 23 // args: value
	#define PROGRAM_INSTRUCTION_TYPECAST 24 // args: type
